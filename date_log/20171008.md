
FATAL: could not receive data from WAL stream  
------------------------------------------------------------------
作者：TT
日期：2017-10-08 18:11:09
分类： PostgreSQL 
标签：postgresql  报错信息  数据库管理  参数  案例  
-------------------------------------------------------------------------------
接到一个有意思的错误，报错如下。（以下是我在我的机器上复现的）
2017-10-08 16:09:25.942 EDT [6391] LOG:  started streaming WAL from primary at 3/96000000 on timeline 1
2017-10-08 16:09:25.942 EDT [6391] FATAL:  could not receive data from WAL stream: ERROR:  requested WAL segment 000000010000000300000096 has already been removed

其实这个报错已经写的很清楚了，该库接不到来自主库的“000000010000000300000096” 中的“3/96000000”内容，所以抛出错误。有可能该日志文件在主库还没有来的急发送给备库就被清理掉了。或者是因为备库关闭时间太长了，主库以为备库死了，就清理掉了。

如果发生了该错误，那么发生的环境应该是postgresql的流复制当中，报错的库是备库。那么好了我们应该如何避免这类问题的发生呢？

有两种方法，
方法1,使用主库的归档命令，如果备库找不到要用的wal文件了，就自己去取。
主库 postgresql.conf
打开归档参数，这样就会在数据库启动后，有进程为你永久保留一份文件。
archive_mode = on
archive_command = 'cp %p /arcfile/%f'

这里多说几句，archive_command中写的是shell命令，而
%p = 归档的路径+wal文件的文件名
%f = 只有wal文件的文件名
每次产生新的wal的时候都会给你把最新完成的复制走。

当然还有一个参数archive_timeout 是说过多久就自动产生一个归档，防止备库等太急:P
注：如果你的库特别忙，这个参数千万别设置，设置了你就看到每过一段时间数据库就库“咔”一下。

当然你可以要求主库多给你至少保留几个wal文件。
wal_keep_segments = 30
相对应的，如果备库活了，最多有多少发送进程发送日志文件过去也要配置高一点，要不备库可能追着时间太长，半天起不来。
max_wal_senders = 15
注：max_wal_senders参数还和max_connect有关，别写太大了，用户的正常链接都搞死了。

以上做的都是主库主动将wal文件多保留一份出来，如果备库发现木有了他怎么去找呢？

备库 recovery.conf
restore_command = 'cp -rf /arcfile/%f %p'
如果备库发现没有了，那么他就会自动去找。理论上使用scp也可以，但是需要互信。

方法2,借助slot，让主库记录发送的最后记录，如果备库没有应用，那么主库坚决不能清理。
主库 postgresql.conf
max_replication_slots=3
开启slot事务槽，对发送的进行记录，这里的数字必须大于等于备库个数，因为一个备库要有一个。在9.4中这个默认是关闭的，10中是开启的，默认10个。

进入主库中给他们开始起名字吧。
postgres=# select pg_create_physical_replication_slot('随便起名字1');

创建完成之后可以通过查询select * from pg_replication_slots看看详细信息。不过这时候看应该还是木有东西的，因为它还需要备库找他注册一下才行。

备库  recovery.conf
primary_slot_name = '随便起名字1'

这样就完成了，当然我是很不建议各位使用中文名字的，因为字符集的乱码可能让你很郁闷。

两种方法都可以解决这样的问题，但是都有缺点。
方法1,
优点：保存两份wal文件，意外不用怕，一份能用就ok。
缺点:需要额外的运维脚本去解决过多wal文件，甚至需要借助主备库上的pg_controldata 命令去对比那些需要那些不需要。

方法2,
优点，数据库主动帮你保留，省去后顾之忧。
缺点，如果备库的主机直接主板崩了，那么主库会无限帮你保留日志文件，你的硬盘要小心了。一个16MB（默认值）。

如果你是使用的第二种方法，并且备库是长时间中断的话，记得监控硬盘，可以用
select pg_drop_replication_slot('s1');
命令删除掉主库发送给备库记录，这样主库就会适当的清理掉日志文件，降低硬盘使用。
